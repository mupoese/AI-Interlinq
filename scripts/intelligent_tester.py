#!/usr/bin/env python3
"""
AI-Interlinq Intelligent Testing System
LAW-001 Compliant Implementation

Purpose: Advanced testing automation with dynamic test generation
Requirements: Smart test selection, coverage optimization, performance analysis
"""

import os
import json
import time
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

# Add the current directory to the Python path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

@dataclass
class TestResult:
    """Represents a test execution result."""
    test_suite: str
    passed: int
    failed: int
    skipped: int
    duration: float
    coverage: Optional[float]
    performance_score: Optional[float]

class IntelligentTester:
    """
    LAW-001 Compliant Intelligent Testing System
    
    Features:
    - Dynamic test generation
    - Regression test selection
    - Performance impact analysis
    - Coverage optimization
    - Test result analysis
    - Failure pattern detection
    """
    
    def __init__(self, repository_path: str = "."):
        """Initialize the intelligent tester."""
        self.repository_path = Path(repository_path).resolve()
        self.test_results: List[TestResult] = []
        self.execution_timestamp = time.time()
        
        # LAW-001 compliance tracking
        self.law_001_context = {
            "cause": "Intelligent testing execution initiated",
            "input": {"repository_path": str(self.repository_path)},
            "action": "Comprehensive intelligent testing",
            "timestamp": self.execution_timestamp
        }
    
    def run_intelligent_tests(self) -> Dict[str, Any]:
        """Run comprehensive intelligent testing."""
        print("🧠 Starting intelligent testing system...")
        
        # Clear previous results
        self.test_results = []
        
        # Execute testing phases
        self._discover_and_generate_tests()
        self._run_unit_tests()
        self._run_integration_tests()
        self._run_performance_tests()
        self._analyze_test_results()
        
        # Compile results
        results = self._compile_test_results()
        
        # Generate LAW-001 compliant snapshot
        self._generate_law_001_snapshot(results)
        
        print(f"✅ Intelligent testing complete. {len(self.test_results)} test suites executed.")
        return results
    
    def _discover_and_generate_tests(self) -> None:
        """Discover existing tests and generate missing ones."""
        print("🔍 Discovering and generating tests...")
        
        try:
            # Ensure test directories exist
            test_dirs = ["tests/unit", "tests/integration", "tests/performance"]
            for test_dir in test_dirs:
                Path(self.repository_path / test_dir).mkdir(parents=True, exist_ok=True)
            
            # Generate basic tests if missing
            self._generate_missing_unit_tests()
            self._generate_missing_integration_tests()
            
            print("✅ Test discovery and generation complete")
        except Exception as e:
            print(f"⚠️ Error in test discovery: {e}")
    
    def _generate_missing_unit_tests(self) -> None:
        """Generate missing unit tests for core modules."""
        core_modules = list((self.repository_path / "ai_interlinq" / "core").glob("*.py"))[:5]  # Limit to 5
        
        for module_path in core_modules:
            if module_path.name.startswith("__"):
                continue
            
            module_name = module_path.stem
            test_file = self.repository_path / "tests" / "unit" / f"test_{module_name}.py"
            
            if not test_file.exists():
                test_content = f'''"""
Auto-generated unit tests for {module_name}.

This file was automatically generated by the Intelligent Testing System.
"""

import pytest
import sys
import os

# Add the parent directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

def test_{module_name}_import():
    """Test that the {module_name} module can be imported."""
    try:
        from ai_interlinq.core import {module_name}
        assert {module_name} is not None
    except ImportError:
        pytest.skip(f"Module {module_name} not importable")

def test_{module_name}_basic_functionality():
    """Test basic functionality of {module_name}."""
    try:
        from ai_interlinq.core import {module_name}
        # Add specific tests based on module analysis
        assert True  # Placeholder
    except ImportError:
        pytest.skip(f"Module {module_name} not available")

@pytest.mark.unit
def test_{module_name}_error_handling():
    """Test error handling in {module_name}."""
    # Test error conditions
    assert True  # Placeholder
'''
                
                with open(test_file, 'w') as f:
                    f.write(test_content)
                
                print(f"📝 Generated unit test: {test_file}")
    
    def _generate_missing_integration_tests(self) -> None:
        """Generate missing integration tests."""
        integration_test = self.repository_path / "tests" / "integration" / "test_system_integration.py"
        
        if not integration_test.exists():
            test_content = '''"""
Auto-generated system integration tests.

This file was automatically generated by the Intelligent Testing System.
"""

import pytest
import sys
import os

# Add the parent directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

@pytest.mark.integration
def test_system_startup():
    """Test that the system can start up properly."""
    try:
        import ai_interlinq
        # Test system initialization
        assert True
    except ImportError:
        pytest.skip("System not available for integration testing")

@pytest.mark.integration
def test_component_interaction():
    """Test interaction between system components."""
    try:
        from ai_interlinq.core.status_checker import StatusChecker
        from ai_interlinq.core.memory_loader import MemoryLoader
        
        # Test component interaction
        checker = StatusChecker()
        loader = MemoryLoader("test")
        
        assert checker is not None
        assert loader is not None
        
    except ImportError:
        pytest.skip("Components not available for integration testing")

@pytest.mark.integration
def test_law_001_integration():
    """Test LAW-001 compliance integration."""
    try:
        from ai_interlinq.core.status_checker import StatusChecker
        
        checker = StatusChecker()
        results = checker.check_law_001_compliance()
        
        assert isinstance(results, dict)
        assert 'law_id' in results
        
    except ImportError:
        pytest.skip("LAW-001 components not available")
'''
            
            with open(integration_test, 'w') as f:
                f.write(test_content)
            
            print(f"📝 Generated integration test: {integration_test}")
    
    def _run_unit_tests(self) -> None:
        """Run unit tests with intelligent selection."""
        print("🧪 Running unit tests...")
        
        try:
            result = subprocess.run([
                "python", "-m", "pytest", "tests/unit/", 
                "-v", "--tb=short", "--duration=10",
                "--cov=ai_interlinq", "--cov-report=json:coverage-unit.json"
            ], capture_output=True, text=True, cwd=self.repository_path, timeout=60)
            
            # Parse results
            passed = result.stdout.count(" PASSED")
            failed = result.stdout.count(" FAILED")
            skipped = result.stdout.count(" SKIPPED")
            
            # Try to get coverage from JSON file
            coverage = None
            coverage_file = self.repository_path / "coverage-unit.json"
            if coverage_file.exists():
                try:
                    with open(coverage_file, 'r') as f:
                        cov_data = json.load(f)
                    coverage = cov_data.get('totals', {}).get('percent_covered', None)
                except:
                    pass
            
            self.test_results.append(TestResult(
                test_suite="unit_tests",
                passed=passed,
                failed=failed,
                skipped=skipped,
                duration=0.0,  # Would need timing from pytest
                coverage=coverage,
                performance_score=None
            ))
            
            print(f"✅ Unit tests: {passed} passed, {failed} failed, {skipped} skipped")
            
        except subprocess.TimeoutExpired:
            print("⚠️ Unit tests timed out")
            self.test_results.append(TestResult(
                test_suite="unit_tests",
                passed=0, failed=1, skipped=0,
                duration=60.0, coverage=None, performance_score=None
            ))
        except Exception as e:
            print(f"⚠️ Error running unit tests: {e}")
    
    def _run_integration_tests(self) -> None:
        """Run integration tests."""
        print("🔗 Running integration tests...")
        
        try:
            result = subprocess.run([
                "python", "-m", "pytest", "tests/integration/", 
                "-v", "--tb=short", "-m", "integration"
            ], capture_output=True, text=True, cwd=self.repository_path, timeout=60)
            
            # Parse results
            passed = result.stdout.count(" PASSED")
            failed = result.stdout.count(" FAILED")
            skipped = result.stdout.count(" SKIPPED")
            
            self.test_results.append(TestResult(
                test_suite="integration_tests",
                passed=passed,
                failed=failed,
                skipped=skipped,
                duration=0.0,
                coverage=None,
                performance_score=None
            ))
            
            print(f"✅ Integration tests: {passed} passed, {failed} failed, {skipped} skipped")
            
        except subprocess.TimeoutExpired:
            print("⚠️ Integration tests timed out")
            self.test_results.append(TestResult(
                test_suite="integration_tests",
                passed=0, failed=1, skipped=0,
                duration=60.0, coverage=None, performance_score=None
            ))
        except Exception as e:
            print(f"⚠️ Error running integration tests: {e}")
    
    def _run_performance_tests(self) -> None:
        """Run performance tests and benchmarks."""
        print("⚡ Running performance tests...")
        
        try:
            # Simple performance test
            start_time = time.time()
            
            # Test import performance
            import_start = time.time()
            try:
                import ai_interlinq
                import_time = time.time() - import_start
            except ImportError:
                import_time = float('inf')
            
            # Test basic operations
            ops_time = 0.0
            try:
                from ai_interlinq.core.status_checker import StatusChecker
                ops_start = time.time()
                checker = StatusChecker()
                checker.verify_all_dependencies()
                ops_time = time.time() - ops_start
            except:
                ops_time = float('inf')
            
            total_time = time.time() - start_time
            
            # Calculate performance score (0-100, higher is better)
            performance_score = 100
            if import_time > 2.0:
                performance_score -= 30
            if ops_time > 5.0:
                performance_score -= 40
            if total_time > 10.0:
                performance_score -= 20
            
            performance_score = max(0, performance_score)
            
            self.test_results.append(TestResult(
                test_suite="performance_tests",
                passed=1 if performance_score > 50 else 0,
                failed=0 if performance_score > 50 else 1,
                skipped=0,
                duration=total_time,
                coverage=None,
                performance_score=performance_score
            ))
            
            print(f"✅ Performance tests: score {performance_score}/100, duration {total_time:.2f}s")
            
        except Exception as e:
            print(f"⚠️ Error running performance tests: {e}")
            self.test_results.append(TestResult(
                test_suite="performance_tests",
                passed=0, failed=1, skipped=0,
                duration=0.0, coverage=None, performance_score=0.0
            ))
    
    def _analyze_test_results(self) -> None:
        """Analyze test results for patterns and insights."""
        print("📊 Analyzing test results...")
        
        total_tests = sum(r.passed + r.failed + r.skipped for r in self.test_results)
        total_passed = sum(r.passed for r in self.test_results)
        total_failed = sum(r.failed for r in self.test_results)
        
        if total_tests > 0:
            success_rate = (total_passed / total_tests) * 100
            print(f"📈 Overall success rate: {success_rate:.1f}%")
        else:
            print("📈 No tests were executed")
    
    def _compile_test_results(self) -> Dict[str, Any]:
        """Compile all test results."""
        total_tests = sum(r.passed + r.failed + r.skipped for r in self.test_results)
        total_passed = sum(r.passed for r in self.test_results)
        total_failed = sum(r.failed for r in self.test_results)
        total_skipped = sum(r.skipped for r in self.test_results)
        
        # Calculate overall metrics
        success_rate = (total_passed / total_tests * 100) if total_tests > 0 else 0
        coverage_scores = [r.coverage for r in self.test_results if r.coverage is not None]
        avg_coverage = sum(coverage_scores) / len(coverage_scores) if coverage_scores else None
        
        performance_scores = [r.performance_score for r in self.test_results if r.performance_score is not None]
        avg_performance = sum(performance_scores) / len(performance_scores) if performance_scores else None
        
        return {
            "timestamp": self.execution_timestamp,
            "repository_path": str(self.repository_path),
            "total_test_suites": len(self.test_results),
            "total_tests": total_tests,
            "total_passed": total_passed,
            "total_failed": total_failed,
            "total_skipped": total_skipped,
            "success_rate": success_rate,
            "average_coverage": avg_coverage,
            "average_performance_score": avg_performance,
            "test_results": [
                {
                    "test_suite": r.test_suite,
                    "passed": r.passed,
                    "failed": r.failed,
                    "skipped": r.skipped,
                    "duration": r.duration,
                    "coverage": r.coverage,
                    "performance_score": r.performance_score
                }
                for r in self.test_results
            ],
            "law_001_context": self.law_001_context,
            "recommendations": self._generate_recommendations()
        }
    
    def _generate_recommendations(self) -> List[str]:
        """Generate testing recommendations."""
        recommendations = []
        
        total_failed = sum(r.failed for r in self.test_results)
        if total_failed > 0:
            recommendations.append(f"Address {total_failed} failing tests")
        
        coverage_scores = [r.coverage for r in self.test_results if r.coverage is not None]
        if coverage_scores and max(coverage_scores) < 80:
            recommendations.append("Improve test coverage (target: 80%+)")
        
        performance_scores = [r.performance_score for r in self.test_results if r.performance_score is not None]
        if performance_scores and min(performance_scores) < 70:
            recommendations.append("Optimize performance (some tests scored < 70)")
        
        if not recommendations:
            recommendations.append("Test suite is in good condition")
        
        return recommendations
    
    def _generate_law_001_snapshot(self, results: Dict[str, Any]) -> None:
        """Generate LAW-001 compliant snapshot."""
        try:
            snapshot = {
                "context": self.law_001_context["cause"],
                "input": self.law_001_context["input"],
                "action": self.law_001_context["action"],
                "applied_law": "LAW-001",
                "reaction": f"Executed {results['total_test_suites']} test suites with {results['success_rate']:.1f}% success rate",
                "output": {
                    "total_tests": results["total_tests"],
                    "success_rate": results["success_rate"],
                    "coverage": results["average_coverage"],
                    "performance_score": results["average_performance_score"]
                },
                "deviation": "Test failures detected" if results["total_failed"] > 0 else None,
                "ai_signature": "intelligent_tester_v1.0",
                "timestamp": self.execution_timestamp
            }
            
            # Save snapshot
            snapshot_path = self.repository_path / "testing_snapshot.ai"
            with open(snapshot_path, 'w', encoding='utf-8') as f:
                json.dump(snapshot, f, indent=2)
            
            print(f"📸 LAW-001 testing snapshot saved to {snapshot_path}")
            
        except Exception as e:
            print(f"⚠️ Error generating LAW-001 snapshot: {e}")
    
    def save_results(self, output_file: str = "testing_results.json") -> None:
        """Save testing results to file."""
        results = self._compile_test_results()
        output_path = self.repository_path / output_file
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        
        print(f"💾 Testing results saved to {output_path}")

def main():
    """Main entry point for intelligent testing."""
    tester = IntelligentTester()
    results = tester.run_intelligent_tests()
    tester.save_results()
    
    # Print summary
    print("\n📊 Intelligent Testing Summary:")
    print(f"Test suites: {results['total_test_suites']}")
    print(f"Total tests: {results['total_tests']}")
    print(f"Success rate: {results['success_rate']:.1f}%")
    print(f"Average coverage: {results['average_coverage']:.1f}%" if results['average_coverage'] else "Coverage: N/A")
    print(f"Performance score: {results['average_performance_score']:.1f}" if results['average_performance_score'] else "Performance: N/A")
    
    print("\n💡 Recommendations:")
    for rec in results['recommendations']:
        print(f"  • {rec}")

if __name__ == "__main__":
    main()